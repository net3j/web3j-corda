{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web3j integration for Corda Introduction web3j-corda is a lightweight client library for working with CorDapps and interacting with different nodes on Corda network. Features Connect to a Corda node Query the available CorDapps in the node Generate CorDapp wrappers to interact with the deployed CorDapps Generate integration tests using a fully Dockerized Corda network to test CorDapps against Generate sample project with a CorDapp contract, workflow and client modules Modules To provide greater flexibility for developers wishing to work with web3j-corda, the project is made up of a number of modules. In dependency order, they are as follows: api : Corda and Network Map client API interfaces. core : Corda and Network Map clients implementation. codegen : CorDapp client code generation libraries. console : Command-line tools for creating and publishing CorDapps. test : Testing tools to run CorDapps in a Corda network. common : Common libraries for all modules.","title":"Home"},{"location":"#web3j-integration-for-corda","text":"","title":"Web3j integration for Corda"},{"location":"#introduction","text":"web3j-corda is a lightweight client library for working with CorDapps and interacting with different nodes on Corda network.","title":"Introduction"},{"location":"#features","text":"Connect to a Corda node Query the available CorDapps in the node Generate CorDapp wrappers to interact with the deployed CorDapps Generate integration tests using a fully Dockerized Corda network to test CorDapps against Generate sample project with a CorDapp contract, workflow and client modules","title":"Features"},{"location":"#modules","text":"To provide greater flexibility for developers wishing to work with web3j-corda, the project is made up of a number of modules. In dependency order, they are as follows: api : Corda and Network Map client API interfaces. core : Corda and Network Map clients implementation. codegen : CorDapp client code generation libraries. console : Command-line tools for creating and publishing CorDapps. test : Testing tools to run CorDapps in a Corda network. common : Common libraries for all modules.","title":"Modules"},{"location":"client/","text":"Web3j client wrappers for Corda Introduction Client code generated by the web3j-corda command can be divided into the following blocks: CorDapps Flows CorDapps block A CorDapp client file is generated for each CorDapp in the path specified to the generate command. This block encapsulates the all information related to the particular CorDapp in an interface. Example code is as follows: /** * CorDapp wrapper. */ @Path( /api/rest/cordapps/ name-of-cordapp-or-jar / ) interface name-of-cordapp : CorDapp { @get:Path( flows ) override val flows: FlowResource // Lists all the flows in a CorDapp // Contains flow definition /** * name-of-cordapp CorDapp lifecycle methods. */ companion object : LifeCycle name-of-cordapp { /** * Loads an existing name-of-cordapp CorDapp instance. */ override fun load(service: CordaService) = ClientBuilder.build( name-of-cordapp ::class.java, service, CordaException.Companion::of) } } Flows blocks Each individual CorDapp can have multiple flows which are listed in the CorDapp block. Each instance of flow can be used to start the flow, using underlying RPC calls. A flow can be defined as mentioned below: /** * Get the flow-name flow. */ @get:Path( flow-complete-path ) val flow-instance : flow-name /** * corDapp-name flow-name flow. */ interface flow-name : Flow { /** * Start the flow-name flow. */ @POST @Produces( application/json ) @Consumes( application/json ) fun start(payload: flow-input-parameters ): flow-output-parameters }","title":"CorDapp client wrappers"},{"location":"client/#web3j-client-wrappers-for-corda","text":"","title":"Web3j client wrappers for Corda"},{"location":"client/#introduction","text":"Client code generated by the web3j-corda command can be divided into the following blocks: CorDapps Flows","title":"Introduction"},{"location":"client/#cordapps-block","text":"A CorDapp client file is generated for each CorDapp in the path specified to the generate command. This block encapsulates the all information related to the particular CorDapp in an interface. Example code is as follows: /** * CorDapp wrapper. */ @Path( /api/rest/cordapps/ name-of-cordapp-or-jar / ) interface name-of-cordapp : CorDapp { @get:Path( flows ) override val flows: FlowResource // Lists all the flows in a CorDapp // Contains flow definition /** * name-of-cordapp CorDapp lifecycle methods. */ companion object : LifeCycle name-of-cordapp { /** * Loads an existing name-of-cordapp CorDapp instance. */ override fun load(service: CordaService) = ClientBuilder.build( name-of-cordapp ::class.java, service, CordaException.Companion::of) } }","title":"CorDapps block"},{"location":"client/#flows-blocks","text":"Each individual CorDapp can have multiple flows which are listed in the CorDapp block. Each instance of flow can be used to start the flow, using underlying RPC calls. A flow can be defined as mentioned below: /** * Get the flow-name flow. */ @get:Path( flow-complete-path ) val flow-instance : flow-name /** * corDapp-name flow-name flow. */ interface flow-name : Flow { /** * Start the flow-name flow. */ @POST @Produces( application/json ) @Consumes( application/json ) fun start(payload: flow-input-parameters ): flow-output-parameters }","title":"Flows blocks"},{"location":"command_line_tools/","text":"Command line utility The web3j-corda CLI makes it easy to: Generate a template CorDapp project and the respective client wrappers Generate client wrappers for existing CorDapps You can install the web3j-corda CLI by running the following command in your terminal: curl -L https://getcorda.web3j.io | bash Create a template CorDapp project To generate a template CorDapp project with the client wrappers: web3j-corda new --name= corDappName --output-dir= output-dir --package-name= packageName Create CorDapp client wrappers To generate a web3j-corda client wrappers to existing CorDapps: web3j-corda generate (--url= openApiUrl | --cordapps-dir= corDapps-dir ) --output-dir= output-dir --package-name= packageName","title":"Command Line Tools"},{"location":"command_line_tools/#command-line-utility","text":"The web3j-corda CLI makes it easy to: Generate a template CorDapp project and the respective client wrappers Generate client wrappers for existing CorDapps You can install the web3j-corda CLI by running the following command in your terminal: curl -L https://getcorda.web3j.io | bash","title":"Command line utility"},{"location":"command_line_tools/#create-a-template-cordapp-project","text":"To generate a template CorDapp project with the client wrappers: web3j-corda new --name= corDappName --output-dir= output-dir --package-name= packageName","title":"Create a template CorDapp project"},{"location":"command_line_tools/#create-cordapp-client-wrappers","text":"To generate a web3j-corda client wrappers to existing CorDapps: web3j-corda generate (--url= openApiUrl | --cordapps-dir= corDapps-dir ) --output-dir= output-dir --package-name= packageName","title":"Create CorDapp client wrappers"},{"location":"connecting_to_node/","text":"Connect to a Corda Node Initialise a connection, and create our Corda client service: val service = CordaService( http://localhost:9000/ ) // URL exposed by Corda OpenAPI connector val corda = Corda.build(service) To print all the nodes connected to the current node: val nodes = corda.api.network.nodes.findAll() To query the list of all running CorDapps: val corDapps = corda.api.corDapps.findAll() To start a flow there are two options depending on whether you want to use a generated CorDapp wrapper or just the Corda API directly: Using the Web3j CorDapp wrapper Please refer on how to use client wrappers in a type-safe way Using Corda API Due to the lack of type-safety, this is not recommended as it can lead to runtime exceptions: // Initialise the parameters of the flow val params = InitiatorParameters( $1 , O=PartyA, L=London, C=GB , false) val issue = corda.api .corDapps.findById( obligation ) .flows.findById( issue-obligation ) // Type-conversions with potential runtime exception! var signedTx = issue.start(params).convert SignedTransaction ()","title":"Connect to Corda node"},{"location":"connecting_to_node/#connect-to-a-corda-node","text":"Initialise a connection, and create our Corda client service: val service = CordaService( http://localhost:9000/ ) // URL exposed by Corda OpenAPI connector val corda = Corda.build(service) To print all the nodes connected to the current node: val nodes = corda.api.network.nodes.findAll() To query the list of all running CorDapps: val corDapps = corda.api.corDapps.findAll() To start a flow there are two options depending on whether you want to use a generated CorDapp wrapper or just the Corda API directly:","title":"Connect to a Corda Node"},{"location":"connecting_to_node/#using-the-web3j-cordapp-wrapper","text":"Please refer on how to use client wrappers in a type-safe way","title":"Using the Web3j CorDapp wrapper"},{"location":"connecting_to_node/#using-corda-api","text":"Due to the lack of type-safety, this is not recommended as it can lead to runtime exceptions: // Initialise the parameters of the flow val params = InitiatorParameters( $1 , O=PartyA, L=London, C=GB , false) val issue = corda.api .corDapps.findById( obligation ) .flows.findById( issue-obligation ) // Type-conversions with potential runtime exception! var signedTx = issue.start(params).convert SignedTransaction ()","title":"Using Corda API"},{"location":"dependencies/","text":"Dependencies To resolve all web3j-corda relevant dependencies, add the following to your project build file: Maven dependency groupId org.web3j.corda /groupId artifactId web3j-corda-core /artifactId version 0.2.0 /version /dependency Gradle dependencies { implementation 'org.web3j.corda:web3j-corda-core:0.2.0' } To use the Web3j Corda test module, you'all also need to include it in your project build file: Maven dependency groupId org.web3j.corda /groupId artifactId web3j-corda-test /artifactId version 0.2.0 /version /dependency Gradle dependencies { testImplementation org.web3j.corda:web3j-corda-test:0.2.0 }","title":"Getting started"},{"location":"dependencies/#dependencies","text":"To resolve all web3j-corda relevant dependencies, add the following to your project build file:","title":"Dependencies"},{"location":"dependencies/#maven","text":"dependency groupId org.web3j.corda /groupId artifactId web3j-corda-core /artifactId version 0.2.0 /version /dependency","title":"Maven"},{"location":"dependencies/#gradle","text":"dependencies { implementation 'org.web3j.corda:web3j-corda-core:0.2.0' } To use the Web3j Corda test module, you'all also need to include it in your project build file:","title":"Gradle"},{"location":"dependencies/#maven_1","text":"dependency groupId org.web3j.corda /groupId artifactId web3j-corda-test /artifactId version 0.2.0 /version /dependency","title":"Maven"},{"location":"dependencies/#gradle_1","text":"dependencies { testImplementation org.web3j.corda:web3j-corda-test:0.2.0 }","title":"Gradle"},{"location":"examples/","text":"Examples Creating a template CorDapp and client wrappers Install the web3j-corda CLI. Run the following command : $ web3j-corda new -n Sample -o destDir -p org.web3j.corda This will create a new template Kotlin CorDapp in destDir , with client wrappers generated in destDir /clients . The business logic for the flow can be added in the following file: workflows/src/main/kotlin/org/web3j/corda/flows/Flows.kt The flow state can be found in: contracts/src/main/kotlin/org/web3j/corda/states/SampleState.kt The contract file can be found in: contracts/src/main/kotlin/org/web3j/corda/contracts/SampleContract.kt The template integration test can be found at: clients/src/test/kotlin/org/web3j/corda/workflows/api/WorkflowsTest.kt In the template integration test you'll find a defined network, such as the following: network = network { directory = File(System.getProperty( user.dir )).parentFile nodes { party { name = O=PartyA, L=London, C=GB } } } Once you've added business logic for the flow and made any changes you wish to make to the contracts and states, you need to run the test (the client will be regenerated automatically): $ ./gradlew test Generating client wrappers for existing CorDapps Install the web3j-corda executable. Provided we have the Obligation CorDapp at the location ~/obligation , we can execute the following command to generate client wrappers: $ web3j-corda generate -d ~/obligation -o ~/obligation/clients -p org.test.web3j.corda This will generate the client wrappers in the provided output directory ~/obligation/clients .","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#creating-a-template-cordapp-and-client-wrappers","text":"Install the web3j-corda CLI. Run the following command : $ web3j-corda new -n Sample -o destDir -p org.web3j.corda This will create a new template Kotlin CorDapp in destDir , with client wrappers generated in destDir /clients . The business logic for the flow can be added in the following file: workflows/src/main/kotlin/org/web3j/corda/flows/Flows.kt The flow state can be found in: contracts/src/main/kotlin/org/web3j/corda/states/SampleState.kt The contract file can be found in: contracts/src/main/kotlin/org/web3j/corda/contracts/SampleContract.kt The template integration test can be found at: clients/src/test/kotlin/org/web3j/corda/workflows/api/WorkflowsTest.kt In the template integration test you'll find a defined network, such as the following: network = network { directory = File(System.getProperty( user.dir )).parentFile nodes { party { name = O=PartyA, L=London, C=GB } } } Once you've added business logic for the flow and made any changes you wish to make to the contracts and states, you need to run the test (the client will be regenerated automatically): $ ./gradlew test","title":"Creating a template CorDapp and client wrappers"},{"location":"examples/#generating-client-wrappers-for-existing-cordapps","text":"Install the web3j-corda executable. Provided we have the Obligation CorDapp at the location ~/obligation , we can execute the following command to generate client wrappers: $ web3j-corda generate -d ~/obligation -o ~/obligation/clients -p org.test.web3j.corda This will generate the client wrappers in the provided output directory ~/obligation/clients .","title":"Generating client wrappers for existing CorDapps"},{"location":"generating/","text":"Generating web3j client wrappers There are two ways to generate web3j client wrappers for given CorDapps. Using the CLI Using a Gradle task Using command-line tool Please refer to the CLI section. Using a Gradle task We should add the task to generate the CorDapp client wrappers using the following: task generateCorDappWrappers(type: JavaExec, group: 'web3j') { classpath = sourceSets.main.runtimeClasspath main = 'org.web3j.corda.console.CordaCommandMain' args 'generate', '--package-name', project.group, '--cordapps-dir', projectDir, '--output-dir', $projectDir/clients } It exposes a Gradle task generateCorDappWrappers which can be invoked to generate client wrappers for the CorDapps.","title":"Generating client wrappers"},{"location":"generating/#generating-web3j-client-wrappers","text":"There are two ways to generate web3j client wrappers for given CorDapps. Using the CLI Using a Gradle task","title":"Generating web3j client wrappers"},{"location":"generating/#using-command-line-tool","text":"Please refer to the CLI section.","title":"Using command-line tool"},{"location":"generating/#using-a-gradle-task","text":"We should add the task to generate the CorDapp client wrappers using the following: task generateCorDappWrappers(type: JavaExec, group: 'web3j') { classpath = sourceSets.main.runtimeClasspath main = 'org.web3j.corda.console.CordaCommandMain' args 'generate', '--package-name', project.group, '--cordapps-dir', projectDir, '--output-dir', $projectDir/clients } It exposes a Gradle task generateCorDappWrappers which can be invoked to generate client wrappers for the CorDapps.","title":"Using a Gradle task"},{"location":"network/","text":"Network queries Once connected to a node, there are a number of network queries that can be run via web3j-corda. To initialise the connection to the node, refer to the section on Connecting to a Corda Node . To query all the nodes connected to the current node: corda.api.network.nodes.findAll() To query nodes with given X500 name: corda.api.network.nodes.findByX500Name( O=PartyB,L=New York,C=US )[0] To query nodes with given host and port: corda.api.network.nodes.findByHostAndPort( party-new-york-us:8080 )[0] To query all connected notaries: corda.api.network.notaries.findAll()","title":"Network queries"},{"location":"network/#network-queries","text":"Once connected to a node, there are a number of network queries that can be run via web3j-corda. To initialise the connection to the node, refer to the section on Connecting to a Corda Node . To query all the nodes connected to the current node: corda.api.network.nodes.findAll() To query nodes with given X500 name: corda.api.network.nodes.findByX500Name( O=PartyB,L=New York,C=US )[0] To query nodes with given host and port: corda.api.network.nodes.findByHostAndPort( party-new-york-us:8080 )[0] To query all connected notaries: corda.api.network.notaries.findAll()","title":"Network queries"},{"location":"quickstart/","text":"Quick start web3j-corda CLI To install the latest vversion of the web3j-corda CLI on Mac OS or Linux, type the following in your terminal: curl -L https://getcorda.web3j.io | bash Then to create a new project, simply run: web3j-corda new -o output-dir -n corDappName -p package-name Or, to generate client wrappers for an existing CorDapp, run: web3j-corda generate -d path-existing-cordapp -o output-dir -p package-name Then to build your project run: ./gradle build For more information on using the web3j-corda CLI, head to the Examples section . The generated Corda project demonstrate a number of core features of web3j-corda , including: Generate CorDapp client wrappers for deployed CorDapps. Interact with a CorDapp listing its nodes and starting flows. Generate integration tests using a Dockerized Corda network to verify the CorDapp.","title":"Quickstart"},{"location":"quickstart/#quick-start","text":"","title":"Quick start"},{"location":"quickstart/#web3j-corda-cli","text":"To install the latest vversion of the web3j-corda CLI on Mac OS or Linux, type the following in your terminal: curl -L https://getcorda.web3j.io | bash Then to create a new project, simply run: web3j-corda new -o output-dir -n corDappName -p package-name Or, to generate client wrappers for an existing CorDapp, run: web3j-corda generate -d path-existing-cordapp -o output-dir -p package-name Then to build your project run: ./gradle build For more information on using the web3j-corda CLI, head to the Examples section . The generated Corda project demonstrate a number of core features of web3j-corda , including: Generate CorDapp client wrappers for deployed CorDapps. Interact with a CorDapp listing its nodes and starting flows. Generate integration tests using a Dockerized Corda network to verify the CorDapp.","title":"web3j-corda CLI"},{"location":"support/","text":"Support Web3 Labs maintain web3j-corda. If you'd like to get in touch, please email us .","title":"Support"},{"location":"support/#support","text":"Web3 Labs maintain web3j-corda. If you'd like to get in touch, please email us .","title":"Support"},{"location":"tests/","text":"Test network reference Web3j Corda provides a DSL that allows you to automatically generate and configure a set of nodes for testing (in a way, is quite similar to a CordForm Gradle task). Here is an example of a Corda network that creates three nodes and start them on Docker containers: val myNetwork = network { directory = File( path-to-corDapp ) nodes { notary { name = O=Notary, L=London, C=GB validating = true } party { name = O=PartyA, L=London, C=GB } party { name = O=PartyB, L=New York, C=US } } } Running this task will create six Docker containers: A Notary node that offers a validating notary service. PartyA and PartyB nodes that: Are not offering any services. Have an RPC user, user1 by default, that will be used by Braid to log into the node via RPC. For each party node, a Braid server exposing their CorDapps using Open API. A Network Map to orchestrate the communication between the nodes. Additionally, all party nodes will include: If directory is a Gradle project, any CorDapps defined in the project\u2019s source folders and its dependencies. If directory is not a Gradle project, all JAR files found in directory and its sub-directories. This means that running the network from the generated sample CorDapp from web3j-corda new , for example, would automatically build and add the sample CorDapp to each node. Configuration The configuration values available in the DSL are as follows: network Defines a dockerized Corda network. Optional configuration version: org.web3j.corda.util.OpenApiVersion Open API version exposed by the nodes (defaults to 3.0.1 ). directory: java.io.File Base directory where CorDapps are located (defaults to user.dir system property). tag: String Network Map Docker image tag (defaults to v0.5.0 ) Read-only configuration image: String Network map Docker image name, cordite/network-map . notaries: Array CordaNotaryNode The notary nodes in this network, indexed by position (e.g. notaries[0] ). parties: Array CordaPartyNode The party nodes in this network, indexed by position (e.g. parties[0] ). api: org.web3j.corda.networkmap.NetworkMapApi The API to interact with the Network Map in this network. service: org.web3j.corda.protocol.CordaService The Corda service to access the Network Map. notary , party Inside a network you can declare nodes using the notary and party blocks. Both have in common the following configuration values: Required configuration name: String The legal identity name of the Corda node. (see myLegalName ), e.g. name = \"O=PartyA, L=London, C=GB\" Optional configuration In addition, each node can specify the following properties: p2pPort: Int Corda P2P port for this node, random by default. (see p2pAddress ), e.g. 10006 rpcSettings { config } Specifies RPC settings for the node. (see rpcSettings ), e.g. (ports are randomized by default) rpcSettings { port = 10006 adminPort = 10026 } rpcUsers { config } Set the RPC users for this node. (see rpcUsers ), e.g. (showing default values) rpcUsers { user = user1 password = test permissions = ALL } autoStart: Boolean Set if this node should start automatically ( true by default). timeOut: java.util.time.Duration Timeout for this Corda node to start (defaults to 5 min). image: String Docker image name, e.g. corda-zulu-4.1 tag: String Docker image tag, e.g. latest Read-only configuration p2pAddress: String Address/port the node uses for inbound communication from other nodes. (see p2pAddress ) e.g. example.com:10002 canonicalName: String Canonical name to be used as Docker container and host name, e.g. notary-london-gb . notary Defines a Corda notary node. Optional configuration validating: Boolean Defines this notary as validation (defaults to false ). party Defines a Corda party node. Optional configuration webPort: Int Braid server port for this node, random by default. Read-only configuration webAddress: String Address/port to communicate with Braid server, e.g. example.com:10002 corda: org.web3j.corda.protocol.Corda Corda instance to interact with this node through the Braid server. Customizing Docker images and tags All of network , notary and party elements allow you to specify which Docker container image name and tag you want to use in your network. This table specifies the default values used: Marker Image name Image tag network cordite/network-map v0.5.0 notary , party corda/corda-zulu-4.1 latest","title":"Test network reference"},{"location":"tests/#test-network-reference","text":"Web3j Corda provides a DSL that allows you to automatically generate and configure a set of nodes for testing (in a way, is quite similar to a CordForm Gradle task). Here is an example of a Corda network that creates three nodes and start them on Docker containers: val myNetwork = network { directory = File( path-to-corDapp ) nodes { notary { name = O=Notary, L=London, C=GB validating = true } party { name = O=PartyA, L=London, C=GB } party { name = O=PartyB, L=New York, C=US } } } Running this task will create six Docker containers: A Notary node that offers a validating notary service. PartyA and PartyB nodes that: Are not offering any services. Have an RPC user, user1 by default, that will be used by Braid to log into the node via RPC. For each party node, a Braid server exposing their CorDapps using Open API. A Network Map to orchestrate the communication between the nodes. Additionally, all party nodes will include: If directory is a Gradle project, any CorDapps defined in the project\u2019s source folders and its dependencies. If directory is not a Gradle project, all JAR files found in directory and its sub-directories. This means that running the network from the generated sample CorDapp from web3j-corda new , for example, would automatically build and add the sample CorDapp to each node.","title":"Test network reference"},{"location":"tests/#configuration","text":"The configuration values available in the DSL are as follows:","title":"Configuration"},{"location":"tests/#network","text":"Defines a dockerized Corda network.","title":"network"},{"location":"tests/#optional-configuration","text":"version: org.web3j.corda.util.OpenApiVersion Open API version exposed by the nodes (defaults to 3.0.1 ). directory: java.io.File Base directory where CorDapps are located (defaults to user.dir system property). tag: String Network Map Docker image tag (defaults to v0.5.0 )","title":"Optional configuration"},{"location":"tests/#read-only-configuration","text":"image: String Network map Docker image name, cordite/network-map . notaries: Array CordaNotaryNode The notary nodes in this network, indexed by position (e.g. notaries[0] ). parties: Array CordaPartyNode The party nodes in this network, indexed by position (e.g. parties[0] ). api: org.web3j.corda.networkmap.NetworkMapApi The API to interact with the Network Map in this network. service: org.web3j.corda.protocol.CordaService The Corda service to access the Network Map.","title":"Read-only configuration"},{"location":"tests/#notary-party","text":"Inside a network you can declare nodes using the notary and party blocks. Both have in common the following configuration values:","title":"notary, party"},{"location":"tests/#required-configuration","text":"name: String The legal identity name of the Corda node. (see myLegalName ), e.g. name = \"O=PartyA, L=London, C=GB\"","title":"Required configuration"},{"location":"tests/#optional-configuration_1","text":"In addition, each node can specify the following properties: p2pPort: Int Corda P2P port for this node, random by default. (see p2pAddress ), e.g. 10006 rpcSettings { config } Specifies RPC settings for the node. (see rpcSettings ), e.g. (ports are randomized by default) rpcSettings { port = 10006 adminPort = 10026 } rpcUsers { config } Set the RPC users for this node. (see rpcUsers ), e.g. (showing default values) rpcUsers { user = user1 password = test permissions = ALL } autoStart: Boolean Set if this node should start automatically ( true by default). timeOut: java.util.time.Duration Timeout for this Corda node to start (defaults to 5 min). image: String Docker image name, e.g. corda-zulu-4.1 tag: String Docker image tag, e.g. latest","title":"Optional configuration"},{"location":"tests/#read-only-configuration_1","text":"p2pAddress: String Address/port the node uses for inbound communication from other nodes. (see p2pAddress ) e.g. example.com:10002 canonicalName: String Canonical name to be used as Docker container and host name, e.g. notary-london-gb .","title":"Read-only configuration"},{"location":"tests/#notary","text":"Defines a Corda notary node.","title":"notary"},{"location":"tests/#optional-configuration_2","text":"validating: Boolean Defines this notary as validation (defaults to false ).","title":"Optional configuration"},{"location":"tests/#party","text":"Defines a Corda party node.","title":"party"},{"location":"tests/#optional-configuration_3","text":"webPort: Int Braid server port for this node, random by default.","title":"Optional configuration"},{"location":"tests/#read-only-configuration_2","text":"webAddress: String Address/port to communicate with Braid server, e.g. example.com:10002 corda: org.web3j.corda.protocol.Corda Corda instance to interact with this node through the Braid server.","title":"Read-only configuration"},{"location":"tests/#customizing-docker-images-and-tags","text":"All of network , notary and party elements allow you to specify which Docker container image name and tag you want to use in your network. This table specifies the default values used: Marker Image name Image tag network cordite/network-map v0.5.0 notary , party corda/corda-zulu-4.1 latest","title":"Customizing Docker images and tags"},{"location":"usage/","text":"Testing with client wrappers To test your CordApps using the generated client wrappers, you can create a test network using the Web3j Corda network DSL . Before that, make sure you have the required test dependencies to your project. // Initialise the test network val myNetwork = network { directory = File( path-to-corDapp ) nodes { notary { name = O=Notary, L=London, C=GB } party { name = O=PartyA, L=London, C=GB } party { name = O=PartyB, L=New York, C=US } } } By using the wrappers generated by the web3j-corda command, one can interact with a CorDapp in a type-safe way: // Initialise the parameters of the flow val params = YoFlowPayload(partyB) // Start the flow with typed parameters and response val output = Yo.load(myNetwork.parties[0].corda.service).flows.yoFlow.start(params)","title":"Testing with client wrappers"},{"location":"usage/#testing-with-client-wrappers","text":"To test your CordApps using the generated client wrappers, you can create a test network using the Web3j Corda network DSL . Before that, make sure you have the required test dependencies to your project. // Initialise the test network val myNetwork = network { directory = File( path-to-corDapp ) nodes { notary { name = O=Notary, L=London, C=GB } party { name = O=PartyA, L=London, C=GB } party { name = O=PartyB, L=New York, C=US } } } By using the wrappers generated by the web3j-corda command, one can interact with a CorDapp in a type-safe way: // Initialise the parameters of the flow val params = YoFlowPayload(partyB) // Start the flow with typed parameters and response val output = Yo.load(myNetwork.parties[0].corda.service).flows.yoFlow.start(params)","title":"Testing with client wrappers"}]}